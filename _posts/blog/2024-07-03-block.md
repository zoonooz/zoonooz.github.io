---
layout: post
title:  "ðŸ“¦Scalable Android App Architecture with Jetpack Compose"
date:   2024-07-03 00:00:00
categories: blog
tag: [android, ios]
---

Working as mobile developer, you've likely encountered the challenges of a complex app, an entangled codebase, and a continuously growing team. Each new feature feels like adding blocks to a Jenga tower that might topple over at any second. And it is not only you, there are many of your colleages trying to do the same in your team or even other teams trying to put a block to your tower unintentionally.

## Vertical vs. Horizontal Teams

When a company grows, a single mobile team may struggle to deliver features quickly enough. To address this, companies often hire more engineers to take care of separate parts of the app. These teams typically fall into two categories: vertical and horizontal.

- **Vertical Teams:** These teams focus on specific screens or features within a screen. They own the entire development process for their assigned features, from design and implementation to testing and maintenance.
- **Horizontal Teams:** These teams focus on specific domain that spread across multiple screens. For example, a "Rewards Team" might handle integrating promotional features across food delivery, taxi, and shopping screens.

<<Horizontal vs Vertical image>>

This doesn't sound bad but the following issues can arise:

- **Limited Collaboration:** Teams may not collaborate enough. Changes by horizontal teams can break functionalities or miss context owned by vertical teams. This necessitates thorough code reviews and discussions.
- **Unclear Ownership:** Sometimes, code from horizontal teams needs to be integrated within vertical team code for functionality. This can lead to confusion about ownership and responsibility for maintenance or bug fixes.
- **Human Error:** Even with close collaboration, mistakes are inevitable.

What if we could fix this by using an architecture.

## Architecture

Instead of looking at the screen as a whole, we can divide it into parts which could be owned by different teams. And with help of declarative UI framework like Jetpack Compose, this is a lot easier than before. From now I will call part of the screen as "Block".

<<Block input output image>>

A Block has clear input and clear output. 
- **Input** is the dependency. What do you need in order for Block to process and return output.
- **Output** is the User Interface. This could be one Composable component.

Here is an example of a Block implementation.
```kotlin
class ShoppingCartBlock(input: ShoppingCartDependencies) {
    ...

    val output: @Composable () -> Unit = {
        // Jetpack Compose Component
    }
}
```

Within a Block it is up to the team to choose what pattern to use. For example, it can be implemented with MVVM(Model-View-ViewModel)

<<Block MVVM Image>>

Blocks can be connected together to form a single UI screen. Let's look at this example screen which consist of many parts which some of them could be owned by different team.

<<Shopping screen highlighting different parts>>

We could implement promotion MVVM Block like this with Dagger for Dependency Injection.
```kotlin
class PromotionBlock(input: PromotionDependencies) {
    private val component by lazy {
        DaggerPromotionBlockComponent.Factory()
            .create(input)
    }

    val output: @Composable () -> Unit = {
        val viewModel = component.viewModel
        PromotionUIComponent(viewModel)
    }
}
```

Going back to `ShoppingCartBlock`, we can add `PromotionBlock` as a child Block by
```kotlin
class ShoppingCartBlock(input: ShoppingCartDependencies) {
    private val component by lazy {
        DaggerShoppingCartBlockComponent.Factory()
            .create(input)
    }

    val output: @Composable () -> Unit = {
        val promotionBlock = PromotionBlock(component)
        ShoppingCartUIComponent(
            vm = component.viewModel
            promotionSlot = promotionBlock.output()
        )
    }
}
```

If the app is not SPA(Single-Page-Application), the top most Block will get the dependencies from Activity, and then forward required dependencies to its child block(s). For instance, the Promotion Block.

Now, let's reivew the current Block tree

<<Block tree image with owner ship + dependency flow (Activity -> ShoppingCart -> Promotion)>>

- Each block could be put into different module, making it easier for each team to declare the ownership. 
- Passing down dependencies from another team's parent Block requires communications (forced by ownership).
- Block only cares about input/output, hence each team can decided on their own architecture pattern and conventions.

## Conclusion

With modern declarative UI frameworks, this idea could be implemented on Android and even on iOS using SwiftUI. You can achieve scalable mobile application architecture without having to use any third-party library at all which reduce learning curve of new team members and less magic code the team will have to understand. You can access the full demo here <<link>>.


